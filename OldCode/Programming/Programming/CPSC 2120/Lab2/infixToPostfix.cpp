/*
 * Name: AJ Garner
 * Date Submitted: 01/31/23
 * Lab Section: 004
 * Assignment Name: Lab 2: Infix to Postfix Conversion
 */

#include <string>
#include <stack>
//iostream is needed to use cout in testerMain
#include <iostream>

using namespace std;

//Converts an infix arithmetic expression into postfix
//The function takes 3 parameters
//First parameter: array of strings for infix expression
//    each string is either an integer number or operator symbol
//Second parameter: number of strings in infix expression
//Third parameter: array of strings for postfix expression
//    generated by function, same format as first parameter
//    assumes that postfix is at least the size of postfix
//Return value: int, number of strings in postfix expression
//    Returns 0 if an error is encountered when converting expression
//    An error occurs with a mismatched parenthesis, e.g. ( ( ) or ( ) ) etc.
//Operator symbols:
// ( : left parenthesis, all operations between this and ")" take place first
// ) : right parenthesis, all op.s back to previous "(" take place first
// * : multiplication, higher precedence - takes place before "+" and "-"
// / : division, higher precedence - takes place before "+" and "-"
// % : remainder, higher precedence - takes place before "+" and "-"
// + : addition, lower precedence - takes place after "*" , "/" , "%"
// - : subtraction, lower precedence - takes place after "*" , "/" , "%"
//The function is not specified to work with any other operator symbols
//Any string in infix may be assumed to be an integer operand if none
// of the above symbols

//This helper function is for check for mismatched parenthesis.
//It will take the infix array and the length as parameters.
//It looks for the first parenthesis and looks for the correct amount of following
//parenthesis.
bool checkForMismatch(int length, string infix[]){
    //stack needed to push everyting to compare
    stack <string> list;

    //This loop will go through infix until it comes across a parenthesis
    for(int i = 0; i < length; ++i){

        //this if statement will push the left parenthesis if found
        if(infix[i][0] == '('){
            list.push(infix[i]);
            continue;
        }

        //This if will look for the right parenthesis
        if(infix[i][0] == ')'){
            
            //if the list is empty, then return 0
            if (list.empty()){
                return 0;
            }

            //else it will pop the stack
            list.pop();
        }
    }
    //return if the list is empty or not, will be a true or false
    return (list.empty());
}

//This helper function will return a value depending on what is passed
//It will then determine what character was pass and return the value
int precedence(char check){

    //returns 2 if there is either / , * , or %
    if (check == '/' || check == '*' || check == '%')
        return 2;
    //returns 1 if it is + or -
    else if (check == '+' || check == '-')
        return 1;
    //returns -1 if there was nothing passed
    else
        return -1;
}

//This is the main body of the function that is used to convert
//infix notation to postfix notation.
//It will first check that there is no mismatched parenthesis.
//Next it will create a stack and start looping through the infix array to see
//if there are any digits. It will then copy those digits to the postfix array.
//It will then check for parenthesis and push them to the stack.
//It will next loop back through until it comes across another ending
//parenthesis and copy the top of the stack to the postfix array and pop the top.
//Next it will check for any operators and check for the precedence using the
//helper function precedence. If the precednce is lower than the top of the stack,
//then it will copy the top of the stack and pop it. If the list is empty, it 
//will push the operator to the top of the stack.
//Lastly, if the list is not empty, it will copy and pop everthing from the stack
//to postfix while it increaments through the array.
//The last return value will be the index of j that has the lenght of the postfix.
int infixToPostfix(string infix[], int length, string postfix[])
{
    //helper function to check for mismatched parenthesis
    if(!checkForMismatch(length, infix)){
        return 0;
    }

    //main stack for operators and left parenthesis
    stack <string> list;

    //index for counting the length of postfix and to increament through it
    int j = 0;

    //This is the main for loop to check everything
    for(int i = 0; i < length; ++i){
        
        //if it is a digit, then copy it to postfix and increament
        if (isdigit(infix[i][0])){
            postfix[j] = infix[i];
            j++;
        }

        //else if it is a left parenthesis, push it to the stack
        else if(infix[i][0] == '(')
            list.push(infix[i]);

        //else if it is a right parenthesis, then do some more
        else if(infix[i][0] == ')'){

            //while the top is not a left parenthesis, then copy the top of 
            //the stack to postfix, then pop and increament
            while (list.top()[0] != '('){
                postfix[j] = list.top();
                list.pop();
                j++;
            }

            //once you break the while loop, pop the left parenthesis off the stack
            if(list.top()[0] == '('){
                list.pop();
            }
        }
        //last check for the for loop
        else{

            //while the stack is not empty and the precedence of the operator
            //is less than the top of the stack, copy the top of the stack to 
            //postfix, pop it, then increament
            while (!list.empty() && 
            precedence(infix[i][0]) <= precedence(list.top()[0])){
                postfix[j] = list.top();
                list.pop();
                j++;
            }

            //if the stack is empty, then push the operator to the top
            list.push(infix[i]);
        }

    }

    //once everything is checked and the stack is not empty, then copy the 
    //top of the stack to postfix, pop it, then increament
    while (!list.empty()){
        postfix[j] = list.top();
        list.pop();
        j++;
    }

    //the stack should be empty now and return the lenght of postfix
    return j;
}


//Main function to test infixToPostfix()
//Should convert 2 + 3 * 4 + ( 5 - 6 + 7 ) * 8
//            to 2 3 4 * + 5 6 - 7 + 8 * +
// int main()
// {
//     string infixExp[] = {"2", "+", "3", "*", "4", "+", "(",
//                          "5", "-", "6", "+", "7", ")", "*",
//                          "8"};
//     string postfixExp[15];
//     int postfixLength;

//     cout << "Infix expression: ";
//     for (int i=0; i<15; i++)
//     {
//         cout << infixExp[i] << " ";
//     }
//     cout << endl;
//     cout << "Length: 15" << endl << endl;

//     postfixLength = infixToPostfix(infixExp, 15, postfixExp);

//     cout << "Postfix expression: ";
//     for (int i=0; i<postfixLength; i++)
//     {
//         cout << postfixExp[i] << " ";
//     }
//     cout << endl;
//     cout << "Length: " << postfixLength << endl;
    
//     return 0;
// }